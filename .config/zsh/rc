#!/usr/bin/env zsh

. $XDG_CONFIG_HOME/shell/aliases
. $XDG_CONFIG_HOME/zsh/opts

autoload -Uz colors && colors

zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path "$XDG_CACHE_DIR/zsh/zcompcache"
zstyle ':completion:*' auto-description '%d'
zstyle ':completion:*' completer _expand _complete _ignored _match _correct \
                       _approximate _prefix
zstyle ':completion:*' expand suffix
zstyle ':completion:*' group-name ''
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-suffixes true
zstyle ':completion:*' matcher-list \
  'm:{[:lower:]}={[:upper:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' \
  'r:|[._-/]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' menu select=1
zstyle ':completion:*' original false
zstyle ':completion:*' preserve-prefix '//[^/]##/'
zstyle ':completion:*' select-prompt \
  %SScrolling active: current selection at %p%s
zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*' use-compctl true
zstyle ':completion:*' verbose true

autoload -U url-quote-magic
zle -N self-insert url-quote-magic

# compaudit doesn't take into account that I might want to manage completions
# through a trusted group.
autoload -Uz compinit
local compaudit_dirs=$(compaudit 2>&1 | tail -n +2)
local ok_pattern='^........-. \d+ root brew'
if [ -n "$compaudit_dirs" ] && ls -ld $compaudit_dirs | ag -v $ok_pattern; then
  echo "compaudit detected insecure directories."
else
  compinit -u -d "$XDG_CACHE_HOME/zsh/zcompdump"
fi

REPORTTIME=5

insert_sudo () { zle beginning-of-line; zle -U "sudo " }
zle -N insert-sudo insert_sudo
bindkey "^[s" insert-sudo
bindkey -e

# Make Apple's update_terminal_cwd function available to ZSH
term_bashrc="/etc/bashrc_$TERM_PROGRAM"

_apple_bash() {
  env -i /bin/bash --noprofile "$@"
}

_apple_bash_eval() {
  local input="$1"
  shift
  _apple_bash -c '. "$0" && eval $(cat)' "$term_bashrc" "$@" <<< "$input"
}

_try_import_apple_bash_function() {
  # Return successfully if the function has already been imported.
  if command -v "$1" > /dev/null; then return; fi

  # Return unsuccessfully if the function defintion file cannot be found.
  if ! [ -r "$term_bashrc" ]; then return "$?"; fi

  # Return unsuccessfully if the file does not define the function.
  if ! _apple_bash_eval 'command -v $1' $1 > /dev/null; then return "$?"; fi

  "$1"() {
    _apple_bash_eval '"$@"' "${funcstack[1]}" "$@"
  }
}

_try_import_apple_bash_function update_terminal_cwd

# Cache this, because it's quite slow.
HOMEBREW_PREFIX="$(brew --prefix)"
HOMEBREW_REPO="$(brew --repo)"

load_from_brew() {
  . "$HOMEBREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
  . "$HOMEBREW_PREFIX/share/zsh-history-substring-search/zsh-history-substring-search.zsh"
  . "$HOMEBREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
  . "$HOMEBREW_PREFIX/opt/liquidprompt/share/liquidprompt"
}

load_from_brew || (brew bundle --file="$ZDOTDIR/Brewfile" && load_from_brew)

bindkey "^[[3~" delete-char
bindkey "^[[H" beginning-of-line
bindkey "^[[F" end-of-line

zmodload zsh/complist
bindkey -M menuselect "^[[Z" reverse-menu-complete

zmodload zsh/terminfo
bindkey "^[[A" history-substring-search-up
bindkey "^[[B" history-substring-search-down

if [ "$(uname -s)" = "Darwin" ]
then
  # Load SSH passphrases from the Keychain.
  # Use an explicit path because Homebrew OpenSSH
  # doesn't have the keychain functionality.
  (/usr/bin/ssh-add -A &) 2> /dev/null
fi

homebrew_taps_dir="$HOMEBREW_REPO/Library/Taps"
command_not_found_repo="$homebrew_taps_dir/homebrew/homebrew-command-not-found"
if [ -d "$command_not_found_repo" ]; then
  . "$command_not_found_repo/handler.sh"
fi

if command -v direnv > /dev/null; then
  eval "$(direnv hook zsh)"
fi

if [ -d "$HOMEBREW_PREFIX/opt/z" ]; then
  source "$HOMEBREW_PREFIX/opt/z/etc/profile.d/z.sh"
fi

if [ -d "$HOMEBREW_PREFIX/opt/fzf" ]; then
  source "$HOMEBREW_PREFIX/opt/fzf/shell/key-bindings.zsh"
fi
